#include "esp_camera.h"
#include <WiFi.h>
#include <WiFiUdp.h>
#include <Preferences.h>
#include <WebServer.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>

// ================= ç¡¬ä»¶å¼•è„š =================
#define BTN_FUNC_PIN 1  // D0
#define LED_PIN      2  // D1
#define LASER_PIN    3  // D2
#define BTN_TRIG_PIN 4  // D3

// ================= è“ç‰™é…ç½‘ =================
#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define DEVICE_NAME         "TONI_PROV"

// ================= ç³»ç»Ÿå˜é‡ =================
#define UDP_PORT 8888
Preferences preferences;
WiFiUDP Udp;
WebServer server(80);
char packetBuffer[255];

// å›¾åƒç¼“å†²åŒº (å­˜ PSRAM)
camera_fb_t * fb_vga = NULL;  // ç§˜ä¹¦å›¾
camera_fb_t * fb_hd = NULL;   // ä¸“å®¶å›¾

// çŠ¶æ€æœº
enum SystemState { STATE_BOOT, STATE_PROVISION, STATE_CONNECTING, STATE_RUNNING };
SystemState sysState = STATE_BOOT;

enum TacState { IDLE, START, SNAP_VGA, WARMUP, SNAP_HD, DONE };
TacState tacState = IDLE;
unsigned long tacTimer = 0;
bool isArmed = true;
bool funcBtnPressed = false;
unsigned long funcBtnTime = 0;

// ================= å‡½æ•°å£°æ˜ =================
void setupCamera();
void startBleProvisioning();
void handleUdpDiscovery();
void handlePhysicalControls();
void runAutonomousSequence();
void takePictureToBuffer(int slot);
void enterDeepSleep();

// ================= è“ç‰™å›è°ƒ =================
class MyCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic *pCharacteristic) {
      String value = pCharacteristic->getValue();
      if (value.length() > 0) {
        Serial.println("ğŸ“± BLE: " + value);
        int commaIndex = value.indexOf(',');
        if (commaIndex != -1) {
          String ssid = value.substring(0, commaIndex);
          String pass = value.substring(commaIndex + 1);
          preferences.begin("wifi_config", false);
          preferences.putString("ssid", ssid);
          preferences.putString("pass", pass);
          preferences.end();
          delay(500); ESP.restart();
        }
      }
    }
};

// ================= SETUP =================
void setup() {
  Serial.begin(115200);
  
  pinMode(BTN_FUNC_PIN, INPUT_PULLUP);
  pinMode(BTN_TRIG_PIN, INPUT_PULLUP);
  esp_sleep_enable_ext0_wakeup((gpio_num_t)BTN_FUNC_PIN, 0);

  ledcAttach(LED_PIN, 5000, 8);
  ledcAttach(LASER_PIN, 5000, 8);
  
  // å¼€æœºç‰¹æ•ˆ
  for(int i=0; i<2; i++) {
    ledcWrite(LED_PIN, 150); delay(100);
    ledcWrite(LED_PIN, 0);   delay(100);
  }
  ledcWrite(LED_PIN, 50);

  setupCamera();

  preferences.begin("wifi_config", true);
  String ssid = preferences.getString("ssid", "");
  String pass = preferences.getString("pass", "");
  preferences.end();

  if (ssid == "") {
    sysState = STATE_PROVISION;
    startBleProvisioning();
  } else {
    WiFi.begin(ssid.c_str(), pass.c_str());
    sysState = STATE_CONNECTING;
  }
}

// ================= LOOP =================
void loop() {
  if (sysState == STATE_PROVISION) {
    static int bri = 0; static int dir = 5;
    bri += dir; if(bri>=255 || bri<=0) dir = -dir;
    ledcWrite(LED_PIN, bri); delay(20);
    return;
  }

  if (sysState == STATE_CONNECTING) {
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\nâœ… IP: " + WiFi.localIP().toString());
      Udp.begin(UDP_PORT);
      
      // 1. è§¦å‘æ¥å£ (App å–Šè¿™ä¸€å—“å­å°±å¼€å§‹å¹²æ´»)
      server.on("/trigger", HTTP_GET, [](){
        server.send(200, "text/plain", "OK");
        if (tacState == IDLE) {
          tacState = START;
          tacTimer = millis();
          Serial.println("ğŸš€ æ”¶åˆ°æŒ‡ä»¤ï¼Œåºåˆ—å¯åŠ¨");
        }
      });

      // 2. å–å›¾æ¥å£ - VGA (App æ”¶åˆ° UDP é€šçŸ¥åæ¥å–)
      server.on("/latest_vga", HTTP_GET, [](){
        if (fb_vga) {
          server.sendHeader("Content-Type", "image/jpeg");
          WiFiClient client = server.client();
          client.write(fb_vga->buf, fb_vga->len);
          Serial.println("ğŸ“¤ VGA å·²å‘é€");
        } else {
          server.send(404, "text/plain", "Not Ready");
        }
      });

      // 3. å–å›¾æ¥å£ - HD (App æ”¶åˆ° UDP é€šçŸ¥åæ¥å–)
      server.on("/latest_hd", HTTP_GET, [](){
        if (fb_hd) {
          server.sendHeader("Content-Type", "image/jpeg");
          WiFiClient client = server.client();
          client.write(fb_hd->buf, fb_hd->len);
          Serial.println("ğŸ“¤ HD å·²å‘é€");
        } else {
          server.send(404, "text/plain", "Not Ready");
        }
      });

      server.begin();
      sysState = STATE_RUNNING;
    } else {
      if (millis() > 30000) {
        sysState = STATE_PROVISION;
        startBleProvisioning();
      }
      delay(500);
    }
    return;
  }

  if (sysState == STATE_RUNNING) {
    handleUdpDiscovery();
    server.handleClient();
    handlePhysicalControls();
    
    // æ‰§è¡Œè‡ªä¸»åºåˆ—
    if (tacState != IDLE) {
      runAutonomousSequence();
    }
  }
}

// ================= V6.3 æ ¸å¿ƒé€»è¾‘ =================

void runAutonomousSequence() {
  unsigned long elapsed = millis() - tacTimer;

  // T+0.1s: å·æ‹ VGA (é™é»˜)
  if (tacState == START && elapsed >= 100) {
    // æ‹ä¹‹å‰é‡Šæ”¾æ—§ç¼“å­˜
    if (fb_vga) { esp_camera_fb_return(fb_vga); fb_vga = NULL; }
    
    // æ‹ç¬¬ä¸€å¼ (åºŸç‰‡)
    takePictureToBuffer(0); // 0=VGA slot, è¿™é‡Œåªæ˜¯ä¸ºäº†çƒ­æœºï¼Œä¸å­˜ä¹Ÿè¡Œï¼Œä½†å­˜äº†ä¿é™©
    // æ‹ç¬¬äºŒå¼ (çœŸå›¾) - T+0.6s é€»è¾‘åˆå¹¶åœ¨è¿™é‡Œåšä¹Ÿè¡Œï¼Œæˆ–è€…åˆ†å¼€
    tacState = SNAP_VGA;
  }

  // T+0.6s: æ‹ VGA å¹¶é€šçŸ¥ App
  else if (tacState == SNAP_VGA && elapsed >= 600) {
    if (fb_vga) { esp_camera_fb_return(fb_vga); fb_vga = NULL; } // æ‰”æ‰0.1sé‚£å¼ 
    
    takePictureToBuffer(0); // æ‹æ–°çš„ VGA
    Serial.println("ğŸ“¸ VGA Captured");
    
    // ğŸ”¥ UDP æ¨é€é€šçŸ¥
    Udp.beginPacket(Udp.remoteIP(), Udp.remotePort()); // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦çŸ¥é“ App IP
    // å¦‚æœ App å‘è¿‡ WHO_IS_TONIï¼Œæˆ‘ä»¬çŸ¥é“ IPã€‚
    // å¦‚æœä¸çŸ¥é“ï¼Œå°±å‘å¹¿æ’­ 255.255.255.255
    Udp.print("EVENT:VGA_READY");
    Udp.endPacket();
    
    tacState = WARMUP;
  }

  // T+0.6s - T+2.0s: æ…¢é—ª
  else if (tacState == WARMUP && elapsed < 2000) {
    int phase = (elapsed / 250) % 2; 
    ledcWrite(LASER_PIN, phase == 0 ? 200 : 0);
    ledcWrite(LED_PIN, phase == 0 ? 255 : 50);
  }

  // T+2.0s: é«˜æ¸…çƒ­æœº
  else if (tacState == WARMUP && elapsed >= 2000) {
    // åˆ‡æ¢åˆ†è¾¨ç‡æ‹åºŸç‰‡
    if (fb_hd) { esp_camera_fb_return(fb_hd); fb_hd = NULL; }
    takePictureToBuffer(1); // 1=HD slot
    // æ‹å®Œæ‰”æ‰(æˆ–è€…è¦†ç›–)ï¼Œæ­¤æ—¶è¿˜åœ¨ PSRAM é‡Œ
    tacState = SNAP_HD;
  }

  // T+2.0s - T+3.0s: å¿«é—ª -> é”å®š
  else if (tacState == SNAP_HD && elapsed < 3000) {
    if (elapsed < 2600) {
       int phase = (elapsed / 100) % 2;
       ledcWrite(LASER_PIN, phase == 0 ? 255 : 0);
       ledcWrite(LED_PIN, phase == 0 ? 255 : 20);
    } else {
       ledcWrite(LASER_PIN, 255); // é”å®š
       ledcWrite(LED_PIN, 150);
    }
  }

  // T+3.0s: å†³æˆ˜æ‹å¤§å›¾
  else if (tacState == SNAP_HD && elapsed >= 3000) {
    ledcWrite(LASER_PIN, 0);
    ledcWrite(LED_PIN, 255); // è¡¥å…‰
    delay(50);
    
    if (fb_hd) { esp_camera_fb_return(fb_hd); fb_hd = NULL; }
    takePictureToBuffer(1); // æ‹æœ€ç»ˆ HD
    Serial.println("ğŸ“¸ HD Captured");
    
    // ğŸ”¥ UDP æ¨é€é€šçŸ¥
    Udp.beginPacket(Udp.remoteIP(), Udp.remotePort());
    Udp.print("EVENT:HD_READY");
    Udp.endPacket();
    
    ledcWrite(LED_PIN, 20); // å¤ä½
    tacState = IDLE; // ç»“æŸ
  }
}

// ğŸ“¸ æ‹ç…§åˆ°åº•å±‚ç¼“å­˜
void takePictureToBuffer(int slot) {
  sensor_t * s = esp_camera_sensor_get();
  if (slot == 0) s->set_framesize(s, FRAMESIZE_VGA);
  else s->set_framesize(s, FRAMESIZE_QXGA);
  
  // æ ¸å¿ƒï¼šcamera_fb_get ä¼šç”³è¯·æ–°å†…å­˜ï¼Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨ç®¡ç†æŒ‡é’ˆ
  camera_fb_t * new_fb = esp_camera_fb_get();
  
  if (!new_fb) { Serial.println("âŒ FB Alloc Fail"); return; }
  
  if (slot == 0) fb_vga = new_fb;
  else fb_hd = new_fb;
}

// ================= å…¶ä»–è¾…åŠ©å‡½æ•° (ä¿æŒä¸å˜) =================
void handleUdpDiscovery() {
  int packetSize = Udp.parsePacket();
  if (packetSize) {
    int len = Udp.read(packetBuffer, 255);
    if (len > 0) packetBuffer[len] = 0;
    String req = String(packetBuffer);
    if (req.indexOf("WHO_IS_TONI") != -1) {
      String reply = "I_AM_TONI,SSID=" + WiFi.SSID() + ",IP=" + WiFi.localIP().toString();
      Udp.beginPacket(Udp.remoteIP(), Udp.remotePort());
      Udp.print(reply);
      Udp.endPacket();
    }
  }
}

void handlePhysicalControls() {
  int btnState = digitalRead(BTN_FUNC_PIN);
  if (btnState == LOW) { 
    if (!funcBtnPressed) { funcBtnPressed = true; funcBtnTime = millis(); }
    if (millis() - funcBtnTime > 2000) enterDeepSleep(); 
  } else {
    if (funcBtnPressed && millis() - funcBtnTime < 2000) {
      isArmed = !isArmed;
      ledcWrite(LED_PIN, isArmed ? 255 : 0); delay(100); 
      ledcWrite(LED_PIN, 0); delay(100);
    }
    funcBtnPressed = false;
  }

  if (isArmed && tacState == IDLE) {
    static int lastTrig = HIGH;
    int trig = digitalRead(BTN_TRIG_PIN);
    if (lastTrig == HIGH && trig == LOW) {
      delay(20);
      if (digitalRead(BTN_TRIG_PIN) == LOW) {
        Serial.println("ğŸ”˜ Trigger!");
        tacState = START; // å¯åŠ¨åºåˆ—
        tacTimer = millis();
      }
    }
    lastTrig = trig;
  }
}

void enterDeepSleep() {
  ledcWrite(LED_PIN, 0); ledcWrite(LASER_PIN, 0);
  esp_deep_sleep_start();
}

void startBleProvisioning() {
  BLEDevice::init(DEVICE_NAME);
  BLEServer *pServer = BLEDevice::createServer();
  BLEService *pService = pServer->createService(SERVICE_UUID);
  BLECharacteristic *pCharacteristic = pService->createCharacteristic(
                                         CHARACTERISTIC_UUID,
                                         BLECharacteristic::PROPERTY_WRITE
                                       );
  pCharacteristic->setCallbacks(new MyCallbacks());
  pService->start();
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06); 
  BLEDevice::startAdvertising();
}

void setupCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = 8; config.pin_d1 = 9; config.pin_d2 = 40; config.pin_d3 = 39;
  config.pin_d4 = 41; config.pin_d5 = 42; config.pin_d6 = 12; config.pin_d7 = 11;
  config.pin_xclk = 10; config.pin_pclk = 13; config.pin_vsync = 38; config.pin_href = 47;
  config.pin_sscb_sda = 4; config.pin_sscb_scl = 5; config.pin_pwdn = -1; config.pin_reset = -1;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size = FRAMESIZE_SVGA; 
  config.jpeg_quality = 12;
  config.fb_count = 2; // å…³é”®ï¼šå¼€å¯ PSRAM åŒç¼“å†²
  config.fb_location = CAMERA_FB_IN_PSRAM;
  
  if (esp_camera_init(&config) != ESP_OK) Serial.println("âŒ Cam Init Fail");
  else Serial.println("âœ… Cam Ready");
}
