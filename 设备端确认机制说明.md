# è®¾å¤‡ç«¯ç¡®è®¤æœºåˆ¶å®ç°è¯´æ˜

## ğŸ“‹ éœ€è¦å®ç°çš„ç¡®è®¤æ¥å£

### 1. å›¾åƒæ¥æ”¶ç¡®è®¤æ¥å£

åœ¨å›ºä»¶ä¸­æ·»åŠ  `/ack_image` æ¥å£ï¼Œç”¨äºæ¥æ”¶Appçš„å›¾åƒæ¥æ”¶ç¡®è®¤ï¼š

```cpp
// åœ¨ HTTP æœåŠ¡å™¨è·¯ç”±ä¸­æ·»åŠ 
server.on("/ack_image", HTTP_GET, [](){
  String type = server.arg("type"); // "VGA" æˆ– "HD"
  Serial.println("âœ… æ”¶åˆ°å›¾åƒç¡®è®¤: " + type);
  server.send(200, "text/plain", "OK");
});
```

### 2. UDPäº‹ä»¶é‡è¯•æœºåˆ¶

ä¿®æ”¹UDPäº‹ä»¶å‘é€é€»è¾‘ï¼Œæ·»åŠ é‡è¯•æœºåˆ¶ï¼š

```cpp
// å…¨å±€å˜é‡
unsigned long vgaEventTime = 0;
unsigned long hdEventTime = 0;
bool vgaAckReceived = false;
bool hdAckReceived = false;
const unsigned long ACK_TIMEOUT = 1000; // 1ç§’è¶…æ—¶
const int MAX_RETRIES = 3;

// åœ¨ runAutonomousSequence() ä¸­ä¿®æ”¹
void runAutonomousSequence() {
  unsigned long elapsed = millis() - tacTimer;

  // T+0.6s: æ‹æ‘„VGAå¹¶å‘é€äº‹ä»¶
  if (tacState == SNAP_VGA && elapsed >= 600) {
    // ... æ‹æ‘„é€»è¾‘ ...
    
    // å‘é€UDPäº‹ä»¶ï¼ˆå¸¦é‡è¯•ï¼‰
    sendVgaEventWithRetry();
    tacState = WARMUP;
  }

  // T+3.0s: æ‹æ‘„HDå¹¶å‘é€äº‹ä»¶
  if (tacState == SNAP_HD && elapsed >= 3000) {
    // ... æ‹æ‘„é€»è¾‘ ...
    
    // å‘é€UDPäº‹ä»¶ï¼ˆå¸¦é‡è¯•ï¼‰
    sendHdEventWithRetry();
    tacState = IDLE;
  }

  // æ£€æŸ¥UDPç¡®è®¤è¶…æ—¶å¹¶é‡è¯•
  checkUdpAckTimeout();
}

// å‘é€VGAäº‹ä»¶ï¼ˆå¸¦é‡è¯•ï¼‰
void sendVgaEventWithRetry() {
  static int retryCount = 0;
  vgaAckReceived = false;
  vgaEventTime = millis();
  
  Udp.beginPacket(Udp.remoteIP(), Udp.remotePort());
  Udp.print("EVENT:VGA_READY");
  Udp.endPacket();
  Serial.println("ğŸ“¤ å‘é€ VGA_READY äº‹ä»¶");
  retryCount = 0;
}

// å‘é€HDäº‹ä»¶ï¼ˆå¸¦é‡è¯•ï¼‰
void sendHdEventWithRetry() {
  static int retryCount = 0;
  hdAckReceived = false;
  hdEventTime = millis();
  
  Udp.beginPacket(Udp.remoteIP(), Udp.remotePort());
  Udp.print("EVENT:HD_READY");
  Udp.endPacket();
  Serial.println("ğŸ“¤ å‘é€ HD_READY äº‹ä»¶");
  retryCount = 0;
}

// æ£€æŸ¥UDPç¡®è®¤è¶…æ—¶å¹¶é‡è¯•
void checkUdpAckTimeout() {
  // æ£€æŸ¥VGAç¡®è®¤
  if (!vgaAckReceived && vgaEventTime > 0) {
    if (millis() - vgaEventTime > ACK_TIMEOUT) {
      static int vgaRetryCount = 0;
      if (vgaRetryCount < MAX_RETRIES) {
        vgaRetryCount++;
        Serial.println("âš ï¸ VGAç¡®è®¤è¶…æ—¶ï¼Œé‡è¯• " + String(vgaRetryCount) + "/" + String(MAX_RETRIES));
        Udp.beginPacket(Udp.remoteIP(), Udp.remotePort());
        Udp.print("EVENT:VGA_READY");
        Udp.endPacket();
        vgaEventTime = millis(); // é‡ç½®è®¡æ—¶å™¨
      } else {
        Serial.println("âŒ VGAç¡®è®¤å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°");
        vgaEventTime = 0;
        vgaRetryCount = 0;
      }
    }
  }

  // æ£€æŸ¥HDç¡®è®¤
  if (!hdAckReceived && hdEventTime > 0) {
    if (millis() - hdEventTime > ACK_TIMEOUT) {
      static int hdRetryCount = 0;
      if (hdRetryCount < MAX_RETRIES) {
        hdRetryCount++;
        Serial.println("âš ï¸ HDç¡®è®¤è¶…æ—¶ï¼Œé‡è¯• " + String(hdRetryCount) + "/" + String(MAX_RETRIES));
        Udp.beginPacket(Udp.remoteIP(), Udp.remotePort());
        Udp.print("EVENT:HD_READY");
        Udp.endPacket();
        hdEventTime = millis(); // é‡ç½®è®¡æ—¶å™¨
      } else {
        Serial.println("âŒ HDç¡®è®¤å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°");
        hdEventTime = 0;
        hdRetryCount = 0;
      }
    }
  }
}

// åœ¨UDPç›‘å¬ä¸­å¤„ç†ç¡®è®¤æ¶ˆæ¯
void handleUdpDiscovery() {
  int packetSize = Udp.parsePacket();
  if (packetSize) {
    char packetBuffer[255];
    int len = Udp.read(packetBuffer, 255);
    if (len > 0) {
      packetBuffer[len] = 0;
      String message = String(packetBuffer);
      
      // å¤„ç†è®¾å¤‡å‘ç°
      if (message == "WHO_IS_TONI?") {
        // ... ç°æœ‰é€»è¾‘ ...
      }
      
      // å¤„ç†ç¡®è®¤æ¶ˆæ¯
      if (message.startsWith("ACK:")) {
        String eventType = message.substring(4);
        if (eventType == "VGA_READY") {
          vgaAckReceived = true;
          Serial.println("âœ… æ”¶åˆ°VGAç¡®è®¤");
        } else if (eventType == "HD_READY") {
          hdAckReceived = true;
          Serial.println("âœ… æ”¶åˆ°HDç¡®è®¤");
        }
      }
    }
  }
}
```

### 3. è®°å½•App IPåœ°å€

åœ¨ `/trigger` æ¥å£ä¸­è®°å½•Appçš„IPåœ°å€ï¼Œç”¨äºUDPäº‹ä»¶å‘é€ï¼š

```cpp
IPAddress appIP;
uint16_t appPort;

server.on("/trigger", HTTP_GET, [](){
  WiFiClient client = server.client();
  appIP = client.remoteIP(); // è®°å½•App IP
  appPort = client.remotePort(); // è®°å½•Appç«¯å£ï¼ˆç”¨äºUDPï¼‰
  
  server.send(200, "text/plain", "OK");
  if (tacState == IDLE) {
    tacState = START;
    tacTimer = millis();
    Serial.println("ğŸš€ æ”¶åˆ°æŒ‡ä»¤ï¼Œåºåˆ—å¯åŠ¨");
    Serial.println("ğŸ“± App IP: " + appIP.toString());
  }
});

// åœ¨å‘é€UDPäº‹ä»¶æ—¶ä½¿ç”¨è®°å½•çš„IP
void sendVgaEventWithRetry() {
  // å¦‚æœappIPå·²è®°å½•ï¼Œä½¿ç”¨å®ƒï¼›å¦åˆ™ä½¿ç”¨Udp.remoteIP()
  IPAddress targetIP = (appIP[0] != 0) ? appIP : Udp.remoteIP();
  uint16_t targetPort = (appPort != 0) ? appPort : Udp.remotePort();
  
  Udp.beginPacket(targetIP, targetPort);
  Udp.print("EVENT:VGA_READY");
  Udp.endPacket();
  // ...
}
```

---

## ğŸ“Š ç¡®è®¤æœºåˆ¶æµç¨‹

### UDPäº‹ä»¶ç¡®è®¤æµç¨‹

1. **è®¾å¤‡å‘é€UDPäº‹ä»¶**
   - è®¾å¤‡å‘é€ `EVENT:VGA_READY` æˆ– `EVENT:HD_READY`
   - å¯åŠ¨ç¡®è®¤è¶…æ—¶è®¡æ—¶å™¨ï¼ˆ1ç§’ï¼‰

2. **Appæ¥æ”¶å¹¶ç¡®è®¤**
   - Appæ”¶åˆ°UDPäº‹ä»¶
   - Appç«‹å³å‘é€ `ACK:VGA_READY` æˆ– `ACK:HD_READY`

3. **è®¾å¤‡æ¥æ”¶ç¡®è®¤**
   - è®¾å¤‡æ”¶åˆ°ç¡®è®¤æ¶ˆæ¯
   - åœæ­¢é‡è¯•è®¡æ—¶å™¨

4. **è¶…æ—¶é‡è¯•**
   - å¦‚æœ1ç§’å†…æœªæ”¶åˆ°ç¡®è®¤ï¼Œè®¾å¤‡é‡å‘UDPäº‹ä»¶
   - æœ€å¤šé‡è¯•3æ¬¡

### å›¾åƒä¼ è¾“ç¡®è®¤æµç¨‹

1. **Appè¯·æ±‚å›¾åƒ**
   - Appå‘é€ `GET /latest_vga` æˆ– `GET /latest_hd`

2. **è®¾å¤‡å‘é€å›¾åƒ**
   - è®¾å¤‡è¿”å›å›¾åƒæ•°æ®ï¼ˆHTTP 200ï¼‰

3. **Appç¡®è®¤æ¥æ”¶**
   - Appæ”¶åˆ°å›¾åƒåï¼Œå‘é€ `GET /ack_image?type=VGA` æˆ– `GET /ack_image?type=HD`
   - è®¾å¤‡è®°å½•ç¡®è®¤

---

## âœ… Appç«¯å·²å®ç°

1. âœ… UDPäº‹ä»¶ç¡®è®¤ï¼šæ”¶åˆ°UDPäº‹ä»¶åè‡ªåŠ¨å‘é€ç¡®è®¤
2. âœ… å›¾åƒä¼ è¾“ç¡®è®¤ï¼šæ”¶åˆ°å›¾åƒåè‡ªåŠ¨å‘é€ç¡®è®¤
3. âœ… è¿æ‹è§¦å‘é‡è¯•ï¼šæœ€å¤šé‡è¯•3æ¬¡
4. âœ… å›¾åƒè·å–é‡è¯•ï¼šæœ€å¤šé‡è¯•3æ¬¡
5. âœ… è§¦å‘æŒ‡ä»¤é‡è¯•ï¼šæœ€å¤šé‡è¯•3æ¬¡

---

## âš ï¸ è®¾å¤‡ç«¯å¾…å®ç°

1. âš ï¸ `/ack_image` æ¥å£
2. âš ï¸ UDPäº‹ä»¶é‡è¯•æœºåˆ¶
3. âš ï¸ UDPç¡®è®¤æ¶ˆæ¯å¤„ç†
4. âš ï¸ App IPåœ°å€è®°å½•

---

## ğŸ¯ ä¼˜å…ˆçº§

**é«˜ä¼˜å…ˆçº§**ï¼š
- UDPäº‹ä»¶é‡è¯•æœºåˆ¶ï¼ˆé˜²æ­¢äº‹ä»¶ä¸¢å¤±ï¼‰
- App IPåœ°å€è®°å½•ï¼ˆç¡®ä¿UDPèƒ½æ­£ç¡®å‘é€ï¼‰

**ä¸­ä¼˜å…ˆçº§**ï¼š
- `/ack_image` æ¥å£ï¼ˆç”¨äºç»Ÿè®¡å’Œæ—¥å¿—ï¼‰

**ä½ä¼˜å…ˆçº§**ï¼š
- ç¡®è®¤è¶…æ—¶ç»Ÿè®¡å’Œæ—¥å¿—

